/-
Copyright (c) 2024 Quang Dao. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Quang Dao
-/

import Mathlib.FieldTheory.Tower
import Mathlib.FieldTheory.Finite.GaloisField
import Mathlib.RingTheory.Adjoin.Basic
-- import Mathlib.Algebra.Polynomial.Basic

/-!
# Binary Tower Fields

Define the binary tower field GF(2^{2^k}) as an iterated quadratic extension of GF(2).

## Main Definitions

- `BinaryTower k` : the binary tower field GF(2^{2^k}) as an iterated quadratic extension of GF(2).

- `ConcreteBinaryTower k` : the concrete implementation of `BinaryTower k` using `BitVec`.

## TODOs

- Define additive NTT basis

## References

- [Wie88] Doug Wiedemann. “An Iterated Quadratic Extension of GF(2)”. In: The Fibonacci Quarterly
  26.4 (1988), pp. 290–295.

- [FP97] John L. Fan and Christof Paar. “On efficient inversion in tower fields of characteristic
  two”. In: Proceedings of IEEE International Symposium on Information Theory. 1997.

- [LCH14] Sian-Jheng Lin, Wei-Ho Chung, and Yunghsiang S. Han. “Novel Polynomial Basis and Its
  Application to Reed–Solomon Erasure Codes”. In: IEEE 55th Annual Symposium on Foundations of
  Computer Science. 2014, pp. 316–325. doi: 10.1109/FOCS.2014.41.

-/


noncomputable section

open Polynomial

notation:10 "GF(" term:10 ")" => GaloisField term 1

-- TODO: consider bundling all the fields below into just one structure, and then make the instances
-- inside accessible. Example from R1CS:
/-
-- Bundle R and its CommSemiring instance
structure RingParams where
  R : Type _
  [commSemiring : CommSemiring R]

-- Make the CommSemiring instance accessible
attribute [instance] RingParams.commSemiring
-/

-- In this definition, the field defined by (BinaryTower k) corresponds to GF(2^{2^{k-1}})
def BinaryTower (k : ℕ) : (F : Type _) × (List F) × (CommRing F) × (Inhabited F) :=
  match k with
  | 0 => ⟨ GF(2), [(1 : GF(2))], inferInstance, inferInstance ⟩
  | k + 1 =>
    let ⟨ F, elts, _, _ ⟩ := BinaryTower k
    let currX : F := elts.getLastI
    let newPoly : Polynomial F := X^2 + (C currX) * X + 1
    let newF := AdjoinRoot newPoly
    let newX := AdjoinRoot.root newPoly
    let newElts := elts.map (fun x => (AdjoinRoot.of newPoly).toFun x)
    ⟨ newF, newElts ++ [newX], inferInstance, inferInstance ⟩

namespace BinaryTower

@[simp]
def field (k : ℕ) := (BinaryTower k).1

@[simp]
instance CommRing (k : ℕ) : CommRing (field k) := (BinaryTower k).2.2.1

@[simp]
instance Inhabited (k : ℕ) : Inhabited (field k) := (BinaryTower k).2.2.2

@[simp]
def list (k : ℕ) : List (field k):= (BinaryTower k).2.1

@[simp]
def poly (k : ℕ) : Polynomial (field (k - 1)) :=
  match k with
  | 0 => 0
  | k + 1 => X^2 + (C (list k).getLastI) * X + 1

@[coe]
theorem field_eq_adjoinRoot_poly (k : ℕ) (k_pos : k > 0) : AdjoinRoot (poly k) = field k := by
  induction k with
  | zero => absurd k_pos ; simp
  | succ k _ => simp [BinaryTower]

instance coe_field_adjoinRoot (k : ℕ) (k_pos : k > 0) : Coe (AdjoinRoot (poly k)) (field k) where
  coe := Eq.mp (field_eq_adjoinRoot_poly k k_pos)


-- We call the special extension field elements Z_k
@[simp]
def Z (k : ℕ) : field k := (list k).getLastI

-- @[simp]
-- theorem Z_eq_adjointRoot_root (k : ℕ) (k_pos : k > 0) [HEq (AdjoinRoot (poly k)) (field k)] :
--     Z k = AdjoinRoot.root (poly k) := by
--   simp [Z, field_eq_adjoinRoot_poly k k_pos]


@[simp]
theorem list_length (k : ℕ) : List.length (BinaryTower k).2.1 = k + 1 := by
  induction k with
  | zero => simp [BinaryTower]
  | succ k IH =>
    conv in Prod.fst _ => simp [BinaryTower]
    simp [List.length_append _ _, IH]

@[simp]
theorem list_nonempty (k : ℕ) : (BinaryTower k).2.1 ≠ [] :=
  List.ne_nil_of_length_eq_add_one (list_length k)


instance polyIrreducible (n : ℕ) : Irreducible (poly n) := sorry


instance polyIrreducibleFact (n : ℕ) : Fact (Irreducible (poly n)) := ⟨polyIrreducible n⟩


instance isFieldBTF (n : ℕ) : Field (BinaryTower n).1 := by
  induction n with
  | zero => simp [BinaryTower] ; exact inferInstance
  | succ n =>
    simp [BinaryTower]
    sorry
    -- apply AdjoinRoot.field (polyIrreducibleFact (n + 1))




-- Possible direction: define alternate definition of BTF as Quotient of MvPolynomial (Fin n) GF(2)
-- by the ideal generated by special field elements
-- What would this definition give us?

end BinaryTower

end

/- Concrete implementation of BTF uses BitVec -/

def ConcreteBinaryTower (k : ℕ) :=
  match k with
  | 0 => BitVec 1
  | k + 1 => BitVec (2 ^ (2 ^ (k - 1)))


-- Define all arithmetic operations



-- Define a field isomorphism
