/-
Copyright (c) 2025 ZKLib Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Quang Dao
-/

import VCVio
import Mathlib.RingTheory.Polynomial.Basic
import Mathlib.Algebra.Polynomial.FieldDivision
import Mathlib.LinearAlgebra.BilinearForm.Properties

/-! # The Algebraic Group Model (With Oblivious Sampling)

We attempt to define the algebraic group model -/

class IsPrimeOrderWith (G : Type*) [Group G] (p : ℕ) [Fact (Nat.Prime p)] where
  hCard : Nat.card G = p

class IsPrimeOrder (G : Type*) [Group G] where
  -- hCard : ∃p, IsPrimeOrderWith G p
  hCard : ∃ p, Nat.Prime p ∧ Nat.card G = p

namespace IsPrimeOrder

variable {G : Type*} [Group G] {p : ℕ} [hp : Fact (Nat.Prime p)] [IsPrimeOrder G]

instance : CommGroup G := sorry

-- instance : IsCyclic G := isCyclic_of_prime_card PrimeOrder.hCard

-- instance : Additive G ≃+ ZMod p := sorry

end IsPrimeOrder

open Polynomial

section AGM

#leansearch "Bilinear maps?"

#check LinearMap.mk₂'

#check LinearMap.BilinForm.linMulLin

-- #check isCyclic_of_prime_card

-- These imply a finite cyclic group of prime order `p`
variable {G : Type*} [Group G] {p : ℕ} [Fact (Nat.Prime p)] (h : Nat.card G = p)

@[ext]
structure GroupRepresentation (prev : List G) (target : G) where
  exponents : List (ZMod p)
  hEq : (prev.zipWith (fun g a => g ^ a.val) exponents).prod = target

#print GroupRepresentation

def Adversary : True := sorry

end AGM

namespace KZG

/-! ## The KZG Polynomial Commitment Scheme -/

-- TODO: figure out how to get `CommGroup` for free
variable {G : Type*} [CommGroup G] {p : ℕ} [Fact (Nat.Prime p)] (h : Nat.card G = p)
  {g : G}

instance {α : Type} [CommGroup α] : AddCommMonoid (Additive α) := inferInstance

variable {G₁ : Type*} [CommGroup G₁] [IsPrimeOrderWith G₁ p] {g₁ : G₁}
  {G₂ : Type*} [CommGroup G₂] [IsPrimeOrderWith G₂ p] {g₂ : G₂}
  {Gₜ : Type*} [CommGroup Gₜ] [IsPrimeOrderWith Gₜ p]
  -- TODO: need to make this a `ZMod p`-linear map
  (pairing : (Additive G₁) →ₗ[ℤ] (Additive G₂) →ₗ[ℤ] (Additive Gₜ))

-- instance : IsCyclic G := isCyclic_of_prime_card h

-- #check unique_of_prime_card

/-- The vector of length `n + 1` that consists of powers:
  `#v[1, g, g ^ a.val, g ^ (a.val ^ 2), ..., g ^ (a.val ^ n)` -/
def towerOfExponents (g : G) (a : ZMod p) (n : ℕ) : Vector G (n + 1) :=
  .ofFn (fun i => g ^ (a.val ^ i.val))

variable {n : ℕ}

/-- The `srs` (structured reference string) for the KZG commitment scheme with secret exponent `a`
    is defined as `#v[g₁, g₁ ^ a, g₁ ^ (a ^ 2), ..., g₁ ^ (a ^ (n - 1))], #v[g₂, g₂ ^ a]` -/
def generateSrs (n : ℕ) (a : ZMod p) : Vector G₁ (n + 1) × Vector G₂ 2 :=
  (towerOfExponents g₁ a n, towerOfExponents g₂ a 1)

/-- One can verify that the `srs` is valid via using the pairing -/
def checkSrs (proveSrs : Vector G₁ (n + 1)) (verifySrs : Vector G₂ 2) : Prop :=
  ∀ i : Fin n,
    pairing (proveSrs[i.succ]) (verifySrs[0]) = pairing (proveSrs[i.castSucc]) (verifySrs[1])

/-- To commit to an `n`-tuple of coefficients `coeffs` (corresponding to a polynomial of degree less
    than `n`), we compute: `∏ i : Fin n, srs[i] ^ (p.coeff i)` -/
def commit (srs : Vector G₁ n) (coeffs : Fin n → ZMod p) : G₁ :=
  ∏ i : Fin n, srs[i] ^ (coeffs i).val

/-- When committing `coeffs` using `srs` generated by `towerOfExponents`, and `coeffs` correspond to
  a polynomial `poly : (ZMod p)[X]` of degree `< n + 1`, we get the result `g₁ ^ (p.eval a).val` -/
theorem commit_eq {g : G₁} {a : ZMod p} (poly : degreeLT (ZMod p) (n + 1)) :
    commit (towerOfExponents g a n) (degreeLTEquiv _ _ poly) = g ^ (poly.1.eval a).val := by
  simp [commit, towerOfExponents]
  simp_rw [← pow_mul, Finset.prod_pow_eq_pow_sum]
  rw [eval_eq_sum_degreeLTEquiv poly.property]
  simp
  -- simp_rw [← ZMod.val_pow]
  sorry

/-- To generate an opening proving that a polynomial `poly` has a certain evaluation at `z`,
  we return the commitment to the polynomial `q(X) = (poly(X) - poly.eval z) / (X - z)` -/
noncomputable def generateOpening (srs : Vector G₁ (n + 1))
    (coeffs : Fin (n + 1) → ZMod p) (z : ZMod p) : G₁ :=
  letI poly : degreeLT (ZMod p) (n + 1) := (degreeLTEquiv (ZMod p) (n + 1)).invFun coeffs
  letI q : degreeLT (ZMod p) (n + 1) :=
    ⟨(poly.val - C (poly.val.eval z)) / (X - C z), by
      apply mem_degreeLT.mpr
      refine lt_of_le_of_lt (degree_div_le _ _) ?_
      refine lt_of_le_of_lt (degree_sub_le _ _) (sup_lt_iff.mpr ?_)
      constructor
      · exact mem_degreeLT.mp poly.property
      · exact lt_of_lt_of_le degree_C_lt (by norm_cast; omega)⟩
  commit srs (degreeLTEquiv (ZMod p) (n + 1) q)

/-- To verify a KZG opening `opening` for a commitment `commitment` at point `z` with claimed
  evaluation `v`, we use the pairing to check "in the exponent" that `p(a) - p(z) = q(a) * (a - z)`,
  where `p` is the polynomial and `q` is the quotient of `p` at `z` -/
noncomputable def verifyOpening (verifySrs : Vector G₂ 2) (commitment : G₁) (opening : G₁)
    (z : ZMod p) (v : ZMod p) : Prop :=
  pairing (commitment / g₁ ^ v.val) (verifySrs[0]) = pairing opening (verifySrs[1] / g₂ ^ z.val)

-- p(a) - p(z) = q(a) * (a - z)
-- e ( C / g₁ ^ v , g₂ ) = e ( O , g₂ ^ a / g₂ ^ z)

-- theorem correctness {g : G} {a : ZMod p} {coeffs : Fin n → ZMod p} {z : ZMod p} :

end KZG
