
\section{A Program Logic for Oracle Reductions}

In this section, we describe a program logic for reasoning about oracle reductions. In other words, we define a number of rules or theorems that govern how oracle reductions can be composed to form larger reductions, and how the larger reductions inherit the security properties of the smaller reductions.

The first of these rules is \emph{sequential composition}.

The second is \emph{virtualization}, which allow for reductions on \emph{virtual} or \emph{ghost} values derivable from the actual values in the context.

The third is \emph{substitution (?)}, which allows for substituting a value in the context with another value, followed by a reduction establishing the relationship between the new and old values.

We will also consider weakening / strengthening / framing of predicates on contexts.

\subsection{Sequential Composition}

The reason why we consider interactive (oracle) reductions at the core of our formalism is that we
can \emph{compose} these reductions to form larger reductions. Equivalently, we can take a complex
\emph{interactive (oracle) proof} (which differs only in that it reduces a relation to the
\emph{trivial} relation that always outputs true) and break it down into a series of smaller
reductions. The advantage of this approach is that we can prove security properties (completeness
and soundness) for each of the smaller reductions, and these properties will automatically transfer
to the larger reductions.

This section is devoted to the composition of interactive (oracle) reductions, and proofs that the
resulting reductions inherit the security properties of the two (or more) constituent reductions.


% \begin{definition}[Sequential Composition of Protocol Type Signatures]
%     \label{def:protocol_spec_composition}
%     \lean{ProtocolSpec.append}
% \end{definition}

% \begin{definition}[Sequential Composition of Provers]
%     \label{def:prover_composition}
%     \lean{Prover.append}
% \end{definition}

% \begin{definition}[Sequential Composition of Oracle Verifiers]
%     \label{def:oracle_verifier_composition}
%     \lean{OracleVerifier.append}
% \end{definition}

% \begin{definition}[Sequential Composition of Oracle Reductions]
%     \label{def:oracle_reduction_composition}
%     \lean{Reduction.append}
% \end{definition}

\subsection{Virtualization}

See the section on sum-check~\ref{sec:sumcheck} for an example.

\begin{definition}[Mapping into Virtual Context]
    \label{def:virtual_context_mapping}
    In order to apply an oracle reduction on virtual data, we will need to provide a mapping from the current context to the virtual context. This includes:
    \begin{itemize}
        \item A mapping from the current public inputs to the virtual public inputs.
        \item A simulation of the oracle inputs for the virtual context using the public and oracle
        inputs for the current context.
        \item A mapping from the current private inputs to the virtual private inputs.
        \item A simulation of the shared oracle for the virtual context using the shared oracle for
        the current context.
    \end{itemize}
\end{definition}

\begin{definition}[Virtual Oracle Reduction]
    \label{def:virtual_oracle_reduction}
    Given a suitable mapping into a virtual context, we may define an oracle reduction via the following construction:
    \begin{itemize}
        \item The prover first applies the mappings to obtain the virtual context. The verifier does the same, but only for the non-private inputs.
        \item The prover and verifier then run the virtual oracle reduction on the virtual context.
    \end{itemize}
\end{definition}

We will show security properties for this virtualization process. One can see that completeness and soundness are inherited from the completeness and soundness of the virtual oracle reduction. However, knowledge soundness is more tricky; this is because we must go back 

\subsection{Substitution}

This transformation happens when we substitute a value in the context with another value, followed
by a reduction establishing the relationship between the new and old values.

Examples include:
\begin{enumerate}
    \item Substituting an oracle input by a public input:
    \begin{itemize}
        \item Often by just revealing the underlying data. This has no change on the prover, and for
        the verifier, this means that any query to the oracle input can be locally computed.
        \item A variant of this is when the oracle input consists of a data along with a proof that
        the data satisfies some predicate. In this case, the verifier needs to additionally check
        that the predicate holds for the substituted data.
        \item Another common substitution is to replace a vector with its Merkle commitment, or a
        polynomial with its polynomial commitment.
    \end{itemize}
    \item Substituting an oracle input by another oracle input, followed by a reduction for each
    oracle query the verifier makes to the old oracle:
    \begin{itemize}
        \item This is also a variant of the previous case, where we do not fully substitue with a
        public input, but do a ``half-substitution'' by substituting with another oracle input. This
        happens e.g. when using a polynomial commitment scheme that is itself based on a vector
        commitment scheme. One can cast protocols like Ligero / Brakedown / FRI / STIR in this
        two-step process.
    \end{itemize}
\end{enumerate}