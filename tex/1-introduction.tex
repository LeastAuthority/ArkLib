\section{Introduction}\label{sec:intro}

\paragraph{Why formal verification of SNARK implementations?}

\paragraph{Why multilinear-based proof systems?}

Spartan~\cite{C:Setty20}, Brakedown

De-duplicating efforts to prove soundness of individual circuits, instead having a ``universal'' approach that allows to prove any program that may be compiled down to virtual machine instructions.

Among the space of zkVMs, Jolt has one of, if not, \emph{the} best-performing prover. It is also based on techniques that have not seen formal verification before, such as multilinear polynomials, sumcheck-based protocols, and binary tower fields (for integration with the Binius polynomial commitment scheme).

\paragraph{Challenges in formally verifying Jolt}

\begin{itemize}
    \item Moving target, since Jolt is still under development
    \item A suite of protocols that have not been formally verified before
\end{itemize}

\subsection{Design Decisions}

% just a running draft of things to say in the final paper

\paragraph{Why Lean?}

\begin{itemize}
    \item Contains Mathlib, a huge undertaking by mathematicians to formalize modern mathematics. Of interests to us are results about finite fields and multivariate polynomials.
    \item Potential future integration with other Mathlib libraries, to formalize protocols such as e.g. Graph Hamiltonicity~\cite{blum...} or Graph 3-Coloring~\cite{...}, or others.
\end{itemize}

The same justifications were given in prior papers (Bailey-Miller and Bailey-Mishra).


\paragraph{New Abstraction: Interactive Oracle Reductions (?)}


Facilitates modular proofs of soundness for interactive protocols. Especially relevant for complex protocols such as Spartan, Lasso, or offline memory checking.



\paragraph{Structure of the Formalization}

\begin{itemize}
    \item Definitions of Interactive Oracle Reductions (IOR), along with specializations to protocols with (multivariate) polynomials.
    \item Specifications for the various subprotocols (such as sumcheck, linear combination, etc.) using Mathlib's Polynomials objects, which are noncomputable (and hence cannot be executed as code).
    \item Completeness and (round-by-round) soundness proofs of these abstract specifications.
    \item Implementation of multilinear polynomials (in the evaluation basis) and binary tower fields. Proofs that these implementations matches the abstract definitions.
    \item Implementations of the subprotocols using our computable implementations of polynomials and binary tower fields. Proofs that these implementations match the specifications.
\end{itemize}

{\color{red} Figures to add: (1) overall structure of the formalization, (2) examples about how larger protocols, such as Spartan, are combinations of smaller subprotocols, such as sumcheck.}



\paragraph{Performance Comparison to an Unverified Implementation} While our goal is not to produce efficient formalized code, we do benchmark our code against the current Rust implementation of Jolt (suitably modified to strip out all other parts of the codebase, leaving only the interactive protocols). {\color{red} Put benchmark info here whenever available. Hopefully they are not too bad, especially for the verifier.}

\iffalse

Potential concerns with the ``verified'' implementation:
\begin{itemize}
    \item Lean automatically uses ``unsafe'' implementations of Array operations, which is equal to the intended operations when the array has size less than the size of the machine word (which is either $32$ or $64$ bits, depending on the architecture).
\end{itemize}

What is the trusted computing base anyway?
\begin{itemize}
    \item If we just look at the executable code \& theorems about them in Lean, then we only need to trust the Lean kernel.
    \item If we use ``lake'' to compile down to C code, then we need to trust both the Lean compiler, and that the optimized versions of e.g. Arrays operations (as defined in Lean) are correct.
    {\color{red} Can we prove that these more efficient versions of array operations are equivalent to the one that has been proven to be correct?}
\end{itemize}

\fi


\subsection{Related Works}\label{sec:related-works}

Prior SNARK verifications:
\begin{itemize}
    \item Bailey-Miller formalizes the soundness of Linear-PCP based SNARKs. Their proofs do not come with executable code.
    \item Bailey-Mishra formalizes the soundness (with executable code) for Marlin, a SNARK based on univariate polynomials. In contrast, our formalization deals with multilinear- and multivariate-based protocols.
\end{itemize}

Formal verification of sumcheck in Isabelle:

Verification of other aspects of SNARKs:
\begin{itemize}
    \item SNARK circuits and relations (citations)
\end{itemize}
These are complementary to our work.

Other projects on cryptography meets formal verification: [give citations and quick descriptions]